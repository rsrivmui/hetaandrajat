---
---
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

    <title>Heta × Rajat</title>
    <meta name="description" content="Heta & Rajat — Light within light." />

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Montserrat:wght@200;300;400&display=swap"
      rel="stylesheet"
    />

    <link rel="stylesheet" href="/global.css" />
  </head>

  <body>
    <div id="canvas-container" aria-hidden="true"></div>

    <div class="ui-layer">
      <div class="header">
        <h1 class="names">HETA × RAJAT</h1>
        <div class="subtitle">Light Within Light</div>
      </div>

      <div class="footer">
        <div id="countdown" class="countdown"></div>
      </div>
    </div>

    <!-- Countdown (IST) -->
    <script is:inline>
      (() => {
        const target = new Date("2026-02-05T00:00:00+05:30").getTime();
        const el = document.getElementById("countdown");
        const pad = (n) => String(n).padStart(2, "0");

        function tick() {
          const now = Date.now();
          let diff = target - now;

          if (diff <= 0) {
            el.innerHTML = "It's Time ✨";
            return;
          }

          const d = Math.floor(diff / (1000 * 60 * 60 * 24));
          diff %= 1000 * 60 * 60 * 24;

          const h = Math.floor(diff / (1000 * 60 * 60));
          diff %= 1000 * 60 * 60;

          const m = Math.floor(diff / (1000 * 60));
          diff %= 1000 * 60;

          const s = Math.floor(diff / 1000);

          el.innerHTML = `
            <div class="time-unit"><span class="time-val">${d}</span><span class="time-lbl">Days</span></div>
            <div class="time-unit"><span class="time-val">${pad(h)}</span><span class="time-lbl">Hrs</span></div>
            <div class="time-unit"><span class="time-val">${pad(m)}</span><span class="time-lbl">Min</span></div>
            <div class="time-unit"><span class="time-val">${pad(s)}</span><span class="time-lbl">Sec</span></div>
          `;
        }

        tick();
        setInterval(tick, 1000);
      })();
    </script>

    <!-- Cosmic simulation (client only, module import) -->
    <script type="module" is:inline>
      const prefersReducedMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches;
      const container = document.getElementById("canvas-container");

      // If user prefers reduced motion, just reveal the background quietly.
      if (prefersReducedMotion) {
        container.style.opacity = "1";
      } else {
        const THREE = await import("https://unpkg.com/three@0.128.0/build/three.module.js");

        // Scene
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050508, 0.02);

        // Camera
        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        container.appendChild(renderer.domElement);

        // Glow texture (programmatic)
        function createGlowTexture() {
          const canvas = document.createElement("canvas");
          canvas.width = 64;
          canvas.height = 64;
          const ctx = canvas.getContext("2d");

          const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
          g.addColorStop(0, "rgba(255,255,255,1)");
          g.addColorStop(0.2, "rgba(255,255,255,0.4)");
          g.addColorStop(0.5, "rgba(255,255,255,0.05)");
          g.addColorStop(1, "rgba(0,0,0,0)");

          ctx.fillStyle = g;
          ctx.fillRect(0, 0, 64, 64);

          const tex = new THREE.CanvasTexture(canvas);
          tex.magFilter = THREE.LinearFilter;
          return tex;
        }
        const glowTexture = createGlowTexture();

        // Stars
        const starGeo = new THREE.SphereGeometry(0.8, 32, 32);

        const star1 = new THREE.Mesh(starGeo, new THREE.MeshBasicMaterial({ color: 0xffddaa }));
        const glow1 = new THREE.Sprite(
          new THREE.SpriteMaterial({
            map: glowTexture,
            color: 0xffaa00,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
          })
        );
        glow1.scale.set(12, 12, 1);
        star1.add(glow1);

        const star2 = new THREE.Mesh(starGeo, new THREE.MeshBasicMaterial({ color: 0xaaddff }));
        const glow2 = new THREE.Sprite(
          new THREE.SpriteMaterial({
            map: glowTexture,
            color: 0x0088ff,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
          })
        );
        glow2.scale.set(12, 12, 1);
        star2.add(glow2);

        const galaxy = new THREE.Group();
        galaxy.add(star1);
        galaxy.add(star2);
        scene.add(galaxy);

        // Stardust trails (GPU-friendly point cloud + shader)
        const PARTICLE_COUNT = 1200;
        const trailGeo = new THREE.BufferGeometry();
        const pos = new Float32Array(PARTICLE_COUNT * 3);
        const life = new Float32Array(PARTICLE_COUNT);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
          pos[i * 3] = 9999;
          pos[i * 3 + 1] = 9999;
          pos[i * 3 + 2] = 9999;
          life[i] = 0;
        }

        trailGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
        trailGeo.setAttribute("life", new THREE.BufferAttribute(life, 1));

        const trailMat = new THREE.ShaderMaterial({
          uniforms: {
            color1: { value: new THREE.Color(0xffaa00) },
            color2: { value: new THREE.Color(0x0088ff) },
          },
          vertexShader: `
            attribute float life;
            varying float vLife;
            void main() {
              vLife = life;
              vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
              gl_PointSize = (10.0 * life) * (10.0 / -mvPosition.z);
              gl_Position = projectionMatrix * mvPosition;
            }
          `,
          fragmentShader: `
            varying float vLife;
            uniform vec3 color1;
            uniform vec3 color2;
            void main() {
              vec2 c = gl_PointCoord - vec2(0.5);
              if (length(c) > 0.5) discard;
              vec3 col = mix(color2, color1, step(0.5, vLife));
              gl_FragColor = vec4(col, vLife * 0.6);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });

        const particles = new THREE.Points(trailGeo, trailMat);
        scene.add(particles);

        let pIndex = 0;

        // Background stars
        const bgGeo = new THREE.BufferGeometry();
        const bg = [];
        for (let i = 0; i < 2000; i++) {
          const r = 40 + Math.random() * 60;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          bg.push(
            r * Math.sin(phi) * Math.cos(theta),
            r * Math.sin(phi) * Math.sin(theta),
            r * Math.cos(phi)
          );
        }
        bgGeo.setAttribute("position", new THREE.Float32BufferAttribute(bg, 3));
        const bgStars = new THREE.Points(
          bgGeo,
          new THREE.PointsMaterial({ color: 0x8899aa, size: 0.2, transparent: true, opacity: 0.6 })
        );
        scene.add(bgStars);

        // Interaction
        const mouse = { x: 0, y: 0 };
        document.addEventListener("mousemove", (e) => {
          mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
          mouse.y = (e.clientY / window.innerHeight) * 2 - 1;
        });

        document.addEventListener(
          "touchmove",
          (e) => {
            if (e.touches?.length) {
              mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
              mouse.y = (e.touches[0].clientY / window.innerHeight) * 2 - 1;
            }
          },
          { passive: true }
        );

        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animate
        let time = 0;
        function animate() {
          time += 0.015;

          const radius = 6 + Math.sin(time * 0.5) * 2;

          star1.position.x = Math.cos(time) * radius;
          star1.position.z = Math.sin(time) * radius * 0.6;
          star1.position.y = Math.sin(time * 2) * 2;

          star2.position.x = Math.cos(time + Math.PI) * radius;
          star2.position.z = Math.sin(time + Math.PI) * radius * 0.6;
          star2.position.y = Math.sin(time * 2 + Math.PI) * 2;

          const emitCount = 4;
          const positions = particles.geometry.attributes.position.array;
          const lifes = particles.geometry.attributes.life.array;

          for (let k = 0; k < emitCount; k++) {
            pIndex = (pIndex + 1) % PARTICLE_COUNT;
            positions[pIndex * 3] = star1.position.x + (Math.random() - 0.5) * 0.5;
            positions[pIndex * 3 + 1] = star1.position.y + (Math.random() - 0.5) * 0.5;
            positions[pIndex * 3 + 2] = star1.position.z + (Math.random() - 0.5) * 0.5;
            lifes[pIndex] = 1.0;

            pIndex = (pIndex + 1) % PARTICLE_COUNT;
            positions[pIndex * 3] = star2.position.x + (Math.random() - 0.5) * 0.5;
            positions[pIndex * 3 + 1] = star2.position.y + (Math.random() - 0.5) * 0.5;
            positions[pIndex * 3 + 2] = star2.position.z + (Math.random() - 0.5) * 0.5;
            lifes[pIndex] = 0.55;
          }

          for (let i = 0; i < PARTICLE_COUNT; i++) {
            if (lifes[i] > 0) lifes[i] -= 0.008;
            else positions[i * 3] = 9999;
          }

          particles.geometry.attributes.position.needsUpdate = true;
          particles.geometry.attributes.life.needsUpdate = true;

          galaxy.rotation.y = time * 0.1;
          galaxy.rotation.z = time * 0.05;

          camera.position.x += (mouse.x * 5 - camera.position.x) * 0.05;
          camera.position.y += (-mouse.y * 5 - camera.position.y) * 0.05;
          camera.lookAt(0, 0, 0);

          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        }

        animate();

        // Reveal
        setTimeout(() => (container.style.opacity = "1"), 100);
      }
    </script>
  </body>
</html>
